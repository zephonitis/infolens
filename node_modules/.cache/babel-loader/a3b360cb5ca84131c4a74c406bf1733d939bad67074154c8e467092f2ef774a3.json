{"ast":null,"code":"const WEXA_API_BASE_URL = process.env.REACT_APP_WEXA_API_BASE_URL || 'https://api.wexa.ai';\nconst WEXA_API_KEY = process.env.REACT_APP_WEXA_API_KEY || '94153bc4-224f-49a6-9af7-2d5394059cca';\nconst WEXA_PROJECT_ID = process.env.REACT_APP_WEXA_PROJECT_ID || '68b6dc5d139ecd7045afa6b6';\nconst WEXA_PROCESS_FLOW_ID = process.env.REACT_APP_WEXA_PROCESS_FLOW_ID || '68b6dc89625644b8e9361e55';\nclass ApiService {\n  async wexaRequest(endpoint, options = {}) {\n    const url = `${WEXA_API_BASE_URL}${endpoint}`;\n    const headers = {\n      'Content-Type': 'application/json',\n      'x-api-key': WEXA_API_KEY,\n      ...options.headers\n    };\n\n    // Default to GET method if not specified\n    const method = options.method || 'GET';\n    console.log('Making Wexa API request:', {\n      url,\n      method,\n      headers\n    });\n    const response = await fetch(url, {\n      ...options,\n      method,\n      headers\n    });\n    console.log('Wexa API response status:', response.status);\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Wexa API error response:', errorText);\n      throw new Error(`Wexa API error: status ${response.status} - ${errorText}`);\n    }\n    const responseData = await response.json();\n    console.log('Wexa API response data:', responseData);\n    return responseData;\n  }\n  async sendQuery(queryRequest) {\n    try {\n      console.log('Starting Wexa API request with credentials (v2):', {\n        projectID: WEXA_PROJECT_ID,\n        processFlowID: WEXA_PROCESS_FLOW_ID,\n        apiBaseUrl: WEXA_API_BASE_URL,\n        apiKeyFromEnv: process.env.REACT_APP_WEXA_API_KEY,\n        apiKeyUsed: WEXA_API_KEY\n      });\n      console.log('Sending Wexa request with URL params - query:', queryRequest.query, 'projectID:', WEXA_PROJECT_ID);\n      const wexaResponse = await this.wexaRequest(`/execute_flow?query=${encodeURIComponent(queryRequest.query)}&projectID=${WEXA_PROJECT_ID}`, {\n        method: 'POST',\n        body: JSON.stringify({\n          agentflow_id: WEXA_PROCESS_FLOW_ID,\n          executed_by: '670cbc86906f68d0ec2970a9',\n          goal: `User Query : ${queryRequest.query}`,\n          input_variables: {}\n        })\n      });\n      console.log('Received Wexa response:', wexaResponse);\n\n      // Poll for execution completion and get results\n      const executionResult = await this.pollExecutionResult(wexaResponse.execution_id);\n\n      // Transform Wexa response to our expected format\n      return this.transformWexaResponse(executionResult, queryRequest.query);\n    } catch (error) {\n      console.error('Error executing Wexa co-worker:', error);\n\n      // More detailed error message\n      let errorMessage = `I encountered an issue while processing your query: \"${queryRequest.query}\".`;\n      if (error instanceof Error) {\n        if (error.message.includes('404')) {\n          errorMessage += ' The API endpoint was not found. Please check the process flow ID.';\n        } else if (error.message.includes('401') || error.message.includes('403')) {\n          errorMessage += ' Authentication failed. Please check the API key.';\n        } else if (error.message.includes('timeout')) {\n          errorMessage += ' The request timed out. The co-worker may be taking longer than expected.';\n        } else {\n          errorMessage += ` Error: ${error.message}`;\n        }\n      }\n      return {\n        answer: errorMessage,\n        sources: []\n      };\n    }\n  }\n  async pollExecutionResult(executionId) {\n    let attempt = 0;\n    while (true) {\n      attempt++;\n      try {\n        // Use the correct Wexa API endpoint for getting execution details\n        const result = await this.wexaRequest(`/execute_flow/${executionId}?projectID=${WEXA_PROJECT_ID}`);\n        console.log(`Polling attempt ${attempt}: Status = ${result.status}`, result);\n        if (result.status === 'completed' || result.status === 'finished') {\n          return result;\n        }\n        if (result.status === 'failed' || result.status === 'error') {\n          throw new Error(`Execution failed: ${result.error || 'Unknown error'}`);\n        }\n\n        // Wait 5 seconds before next poll\n        await new Promise(resolve => setTimeout(resolve, 5000));\n      } catch (error) {\n        console.error(`Polling attempt ${attempt} failed:`, error);\n\n        // If it's a network error, wait and retry\n        if (error instanceof Error && (error.message.includes('fetch') || error.message.includes('network'))) {\n          console.log('Network error, retrying in 5 seconds...');\n          await new Promise(resolve => setTimeout(resolve, 5000));\n          continue;\n        }\n\n        // For other errors, throw immediately\n        throw error;\n      }\n    }\n  }\n  async getExecutionDetails(executionId) {\n    return this.wexaRequest(`/execute_flow/${executionId}?projectID=${WEXA_PROJECT_ID}`, {\n      method: 'GET'\n    });\n  }\n  transformWexaResponse(executionResult, originalQuery) {\n    let answer = 'I processed your query but did not receive a clear response.';\n    let sources = [];\n    console.log('Transforming Wexa response:', executionResult);\n\n    // Extract answer from agents_output or conclusion\n    if (executionResult.conclusion) {\n      answer = String(executionResult.conclusion);\n    } else if (executionResult.agents_output && executionResult.agents_output.length > 0) {\n      const lastOutput = executionResult.agents_output[executionResult.agents_output.length - 1];\n      const rawAnswer = lastOutput.output || lastOutput.response || lastOutput.content || lastOutput.result || answer;\n\n      // Handle different response formats\n      if (typeof rawAnswer === 'object' && rawAnswer !== null) {\n        // If it's an object, try to extract meaningful content\n        if (rawAnswer.text) {\n          answer = String(rawAnswer.text);\n        } else if (rawAnswer.content) {\n          answer = String(rawAnswer.content);\n        } else if (rawAnswer.message) {\n          answer = String(rawAnswer.message);\n        } else {\n          // Convert object to readable JSON\n          answer = JSON.stringify(rawAnswer, null, 2);\n        }\n      } else {\n        answer = String(rawAnswer);\n      }\n    }\n\n    // Ensure answer is always a string and not [object Object]\n    if (typeof answer !== 'string' || answer === '[object Object]') {\n      console.warn('Invalid answer format detected, converting:', answer);\n      answer = typeof answer === 'object' ? JSON.stringify(answer, null, 2) : String(answer);\n    }\n\n    // Extract sources if available in the execution result\n    if (executionResult.sources && Array.isArray(executionResult.sources)) {\n      sources = executionResult.sources;\n    } else if (executionResult.agents_output && Array.isArray(executionResult.agents_output)) {\n      // Try to extract sources from agent outputs\n      sources = executionResult.agents_output.filter(output => output.sources || output.documents).flatMap(output => output.sources || output.documents || []);\n    }\n    return {\n      answer,\n      sources: sources.map((source, index) => ({\n        document_id: source.document_id || source.id || `doc_${index}`,\n        relevance_score: source.relevance_score || source.score || 0.8,\n        content: source.content || source.text || source.summary || '',\n        metadata: source.metadata || {\n          type: 'knowledge_base'\n        }\n      }))\n    };\n  }\n  async getConversations(userId) {\n    // For now, return empty array as conversations are managed locally\n    // In future, this could integrate with Wexa's conversation storage\n    return [];\n  }\n  async getConversation(conversationId) {\n    // For now, throw error as conversations are managed locally\n    throw new Error('Conversation not found - using local storage');\n  }\n  async createConversation(userId, title) {\n    // For now, conversations are created locally in the hook\n    throw new Error('Conversations are managed locally');\n  }\n  async saveMessage(conversationId, message) {\n    // For now, messages are saved locally in the hook\n    // In future, this could integrate with Wexa's conversation storage\n    return;\n  }\n}\nexport const apiService = new ApiService();","map":{"version":3,"names":["WEXA_API_BASE_URL","process","env","REACT_APP_WEXA_API_BASE_URL","WEXA_API_KEY","REACT_APP_WEXA_API_KEY","WEXA_PROJECT_ID","REACT_APP_WEXA_PROJECT_ID","WEXA_PROCESS_FLOW_ID","REACT_APP_WEXA_PROCESS_FLOW_ID","ApiService","wexaRequest","endpoint","options","url","headers","method","console","log","response","fetch","status","ok","errorText","text","error","Error","responseData","json","sendQuery","queryRequest","projectID","processFlowID","apiBaseUrl","apiKeyFromEnv","apiKeyUsed","query","wexaResponse","encodeURIComponent","body","JSON","stringify","agentflow_id","executed_by","goal","input_variables","executionResult","pollExecutionResult","execution_id","transformWexaResponse","errorMessage","message","includes","answer","sources","executionId","attempt","result","Promise","resolve","setTimeout","getExecutionDetails","originalQuery","conclusion","String","agents_output","length","lastOutput","rawAnswer","output","content","warn","Array","isArray","filter","documents","flatMap","map","source","index","document_id","id","relevance_score","score","summary","metadata","type","getConversations","userId","getConversation","conversationId","createConversation","title","saveMessage","apiService"],"sources":["C:/Users/ashwi/OneDrive/Desktop/LightRiver UI/src/services/api.ts"],"sourcesContent":["import { QueryRequest, QueryResponse, Conversation, Message, WexaExecuteFlowRequest, WexaExecuteFlowResponse } from '../types';\n\nconst WEXA_API_BASE_URL = process.env.REACT_APP_WEXA_API_BASE_URL || 'https://api.wexa.ai';\nconst WEXA_API_KEY = process.env.REACT_APP_WEXA_API_KEY || '94153bc4-224f-49a6-9af7-2d5394059cca';\nconst WEXA_PROJECT_ID = process.env.REACT_APP_WEXA_PROJECT_ID || '68b6dc5d139ecd7045afa6b6';\nconst WEXA_PROCESS_FLOW_ID = process.env.REACT_APP_WEXA_PROCESS_FLOW_ID || '68b6dc89625644b8e9361e55';\n\nclass ApiService {\n  private async wexaRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const url = `${WEXA_API_BASE_URL}${endpoint}`;\n    \n    const headers = {\n      'Content-Type': 'application/json',\n      'x-api-key': WEXA_API_KEY,\n      ...options.headers,\n    };\n\n    // Default to GET method if not specified\n    const method = options.method || 'GET';\n\n    console.log('Making Wexa API request:', { url, method, headers });\n\n    const response = await fetch(url, {\n      ...options,\n      method,\n      headers,\n    });\n\n    console.log('Wexa API response status:', response.status);\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('Wexa API error response:', errorText);\n      throw new Error(`Wexa API error: status ${response.status} - ${errorText}`);\n    }\n\n    const responseData = await response.json();\n    console.log('Wexa API response data:', responseData);\n    return responseData;\n  }\n\n  async sendQuery(queryRequest: QueryRequest): Promise<QueryResponse> {\n    try {\n      console.log('Starting Wexa API request with credentials (v2):', {\n        projectID: WEXA_PROJECT_ID,\n        processFlowID: WEXA_PROCESS_FLOW_ID,\n        apiBaseUrl: WEXA_API_BASE_URL,\n        apiKeyFromEnv: process.env.REACT_APP_WEXA_API_KEY,\n        apiKeyUsed: WEXA_API_KEY\n      });\n\n      console.log('Sending Wexa request with URL params - query:', queryRequest.query, 'projectID:', WEXA_PROJECT_ID);\n\n      const wexaResponse = await this.wexaRequest<WexaExecuteFlowResponse>(\n        `/execute_flow?query=${encodeURIComponent(queryRequest.query)}&projectID=${WEXA_PROJECT_ID}`,\n        {\n          method: 'POST',\n          body: JSON.stringify({\n            agentflow_id: WEXA_PROCESS_FLOW_ID,\n            executed_by: '670cbc86906f68d0ec2970a9',\n            goal: `User Query : ${queryRequest.query}`,\n            input_variables: {}\n          }),\n        }\n      );\n\n      console.log('Received Wexa response:', wexaResponse);\n\n      // Poll for execution completion and get results\n      const executionResult = await this.pollExecutionResult(wexaResponse.execution_id);\n\n      // Transform Wexa response to our expected format\n      return this.transformWexaResponse(executionResult, queryRequest.query);\n    } catch (error) {\n      console.error('Error executing Wexa co-worker:', error);\n      \n      // More detailed error message\n      let errorMessage = `I encountered an issue while processing your query: \"${queryRequest.query}\".`;\n      \n      if (error instanceof Error) {\n        if (error.message.includes('404')) {\n          errorMessage += ' The API endpoint was not found. Please check the process flow ID.';\n        } else if (error.message.includes('401') || error.message.includes('403')) {\n          errorMessage += ' Authentication failed. Please check the API key.';\n        } else if (error.message.includes('timeout')) {\n          errorMessage += ' The request timed out. The co-worker may be taking longer than expected.';\n        } else {\n          errorMessage += ` Error: ${error.message}`;\n        }\n      }\n      \n      return {\n        answer: errorMessage,\n        sources: [],\n      };\n    }\n  }\n\n  private async pollExecutionResult(executionId: string): Promise<any> {\n    let attempt = 0;\n    \n    while (true) {\n      attempt++;\n      try {\n        // Use the correct Wexa API endpoint for getting execution details\n        const result = await this.wexaRequest<any>(\n          `/execute_flow/${executionId}?projectID=${WEXA_PROJECT_ID}`\n        );\n\n        console.log(`Polling attempt ${attempt}: Status = ${result.status}`, result);\n\n        if (result.status === 'completed' || result.status === 'finished') {\n          return result;\n        }\n\n        if (result.status === 'failed' || result.status === 'error') {\n          throw new Error(`Execution failed: ${result.error || 'Unknown error'}`);\n        }\n\n        // Wait 5 seconds before next poll\n        await new Promise(resolve => setTimeout(resolve, 5000));\n      } catch (error) {\n        console.error(`Polling attempt ${attempt} failed:`, error);\n        \n        // If it's a network error, wait and retry\n        if (error instanceof Error && (error.message.includes('fetch') || error.message.includes('network'))) {\n          console.log('Network error, retrying in 5 seconds...');\n          await new Promise(resolve => setTimeout(resolve, 5000));\n          continue;\n        }\n        \n        // For other errors, throw immediately\n        throw error;\n      }\n    }\n  }\n\n  async getExecutionDetails(executionId: string): Promise<any> {\n    return this.wexaRequest<any>(\n      `/execute_flow/${executionId}?projectID=${WEXA_PROJECT_ID}`,\n      {\n        method: 'GET'\n      }\n    );\n  }\n\n  private transformWexaResponse(executionResult: any, originalQuery: string): QueryResponse {\n    let answer = 'I processed your query but did not receive a clear response.';\n    let sources: any[] = [];\n\n    console.log('Transforming Wexa response:', executionResult);\n\n    // Extract answer from agents_output or conclusion\n    if (executionResult.conclusion) {\n      answer = String(executionResult.conclusion);\n    } else if (executionResult.agents_output && executionResult.agents_output.length > 0) {\n      const lastOutput = executionResult.agents_output[executionResult.agents_output.length - 1];\n      const rawAnswer = lastOutput.output || lastOutput.response || lastOutput.content || lastOutput.result || answer;\n      \n      // Handle different response formats\n      if (typeof rawAnswer === 'object' && rawAnswer !== null) {\n        // If it's an object, try to extract meaningful content\n        if (rawAnswer.text) {\n          answer = String(rawAnswer.text);\n        } else if (rawAnswer.content) {\n          answer = String(rawAnswer.content);\n        } else if (rawAnswer.message) {\n          answer = String(rawAnswer.message);\n        } else {\n          // Convert object to readable JSON\n          answer = JSON.stringify(rawAnswer, null, 2);\n        }\n      } else {\n        answer = String(rawAnswer);\n      }\n    }\n\n    // Ensure answer is always a string and not [object Object]\n    if (typeof answer !== 'string' || answer === '[object Object]') {\n      console.warn('Invalid answer format detected, converting:', answer);\n      answer = typeof answer === 'object' ? JSON.stringify(answer, null, 2) : String(answer);\n    }\n\n    // Extract sources if available in the execution result\n    if (executionResult.sources && Array.isArray(executionResult.sources)) {\n      sources = executionResult.sources;\n    } else if (executionResult.agents_output && Array.isArray(executionResult.agents_output)) {\n      // Try to extract sources from agent outputs\n      sources = executionResult.agents_output\n        .filter((output: any) => output.sources || output.documents)\n        .flatMap((output: any) => output.sources || output.documents || []);\n    }\n\n    return {\n      answer,\n      sources: sources.map((source: any, index: number) => ({\n        document_id: source.document_id || source.id || `doc_${index}`,\n        relevance_score: source.relevance_score || source.score || 0.8,\n        content: source.content || source.text || source.summary || '',\n        metadata: source.metadata || { type: 'knowledge_base' },\n      })),\n    };\n  }\n\n  async getConversations(userId: string): Promise<Conversation[]> {\n    // For now, return empty array as conversations are managed locally\n    // In future, this could integrate with Wexa's conversation storage\n    return [];\n  }\n\n  async getConversation(conversationId: string): Promise<Conversation> {\n    // For now, throw error as conversations are managed locally\n    throw new Error('Conversation not found - using local storage');\n  }\n\n  async createConversation(userId: string, title: string): Promise<Conversation> {\n    // For now, conversations are created locally in the hook\n    throw new Error('Conversations are managed locally');\n  }\n\n  async saveMessage(conversationId: string, message: Message): Promise<void> {\n    // For now, messages are saved locally in the hook\n    // In future, this could integrate with Wexa's conversation storage\n    return;\n  }\n}\n\nexport const apiService = new ApiService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
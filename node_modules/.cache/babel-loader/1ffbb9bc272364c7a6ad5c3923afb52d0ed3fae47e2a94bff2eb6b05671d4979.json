{"ast":null,"code":"const WEXA_API_BASE_URL = process.env.REACT_APP_WEXA_API_BASE_URL || 'https://api.wexa.ai';\nconst WEXA_API_KEY = process.env.REACT_APP_WEXA_API_KEY || 'ddee0dbb-08d1-48de-898b-67f77df8f773';\nconst WEXA_PROJECT_ID = process.env.REACT_APP_WEXA_PROJECT_ID || '68b6dc5d139ecd7045afa6b6';\nconst WEXA_PROCESS_FLOW_ID = process.env.REACT_APP_WEXA_PROCESS_FLOW_ID || '68b6dc89625644b8e9361e55';\nclass ApiService {\n  async wexaRequest(endpoint, options = {}) {\n    const url = `${WEXA_API_BASE_URL}${endpoint}`;\n    const config = {\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': WEXA_API_KEY,\n        ...options.headers\n      },\n      ...options\n    };\n    try {\n      const response = await fetch(url, config);\n      if (!response.ok) {\n        throw new Error(`Wexa API error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Wexa API request failed:', error);\n      throw error;\n    }\n  }\n  async sendQuery(queryRequest) {\n    try {\n      // Execute the Wexa co-worker process flow\n      const wexaRequest = {\n        agentflow_id: WEXA_PROCESS_FLOW_ID,\n        executed_by: queryRequest.user_id,\n        goal: \"process_user_query\",\n        input_variables: {\n          user_query: queryRequest.query,\n          session_id: queryRequest.session_id\n        },\n        projectID: WEXA_PROJECT_ID\n      };\n      const wexaResponse = await this.wexaRequest(`/execute_flow?projectID=${WEXA_PROJECT_ID}`, {\n        method: 'POST',\n        body: JSON.stringify(wexaRequest)\n      });\n\n      // Poll for execution completion and get results\n      const executionResult = await this.pollExecutionResult(wexaResponse.execution_id);\n\n      // Transform Wexa response to our expected format\n      return this.transformWexaResponse(executionResult, queryRequest.query);\n    } catch (error) {\n      console.error('Error executing Wexa co-worker:', error);\n\n      // Fallback response for demo/testing\n      return {\n        answer: `I apologize, but I encountered an issue while processing your query: \"${queryRequest.query}\". Please ensure the Wexa co-worker is properly configured and try again.`,\n        sources: []\n      };\n    }\n  }\n  async pollExecutionResult(executionId, maxAttempts = 30) {\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        const result = await this.wexaRequest(`/execute_flow/execution/${executionId}?projectID=${WEXA_PROJECT_ID}`);\n        console.log(`Polling attempt ${attempt + 1}: Status = ${result.status}`);\n        if (result.status === 'completed' || result.status === 'finished') {\n          return result;\n        }\n        if (result.status === 'failed' || result.status === 'error') {\n          throw new Error(`Execution failed: ${result.error || 'Unknown error'}`);\n        }\n\n        // Wait 2 seconds before next poll\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      } catch (error) {\n        console.error(`Polling attempt ${attempt + 1} failed:`, error);\n        if (attempt === maxAttempts - 1) {\n          throw error;\n        }\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n    }\n    throw new Error('Execution timeout - process took too long to complete');\n  }\n  async getExecutionDetails(executionId) {\n    return this.wexaRequest(`/execute_flow/execution/${executionId}?projectID=${WEXA_PROJECT_ID}`);\n  }\n  transformWexaResponse(executionResult, originalQuery) {\n    let answer = 'I processed your query but did not receive a clear response.';\n    let sources = [];\n\n    // Extract answer from agents_output or conclusion\n    if (executionResult.conclusion) {\n      answer = executionResult.conclusion;\n    } else if (executionResult.agents_output && executionResult.agents_output.length > 0) {\n      const lastOutput = executionResult.agents_output[executionResult.agents_output.length - 1];\n      answer = lastOutput.output || lastOutput.response || lastOutput.content || answer;\n    }\n\n    // Extract sources if available in the execution result\n    if (executionResult.sources) {\n      sources = executionResult.sources;\n    } else if (executionResult.agents_output) {\n      // Try to extract sources from agent outputs\n      sources = executionResult.agents_output.filter(output => output.sources || output.documents).flatMap(output => output.sources || output.documents || []);\n    }\n    return {\n      answer,\n      sources: sources.map((source, index) => ({\n        document_id: source.document_id || source.id || `doc_${index}`,\n        relevance_score: source.relevance_score || source.score || 0.8,\n        content: source.content || source.text || source.summary || '',\n        metadata: source.metadata || {\n          type: 'knowledge_base'\n        }\n      }))\n    };\n  }\n  async getConversations(userId) {\n    // For now, return empty array as conversations are managed locally\n    // In future, this could integrate with Wexa's conversation storage\n    return [];\n  }\n  async getConversation(conversationId) {\n    // For now, throw error as conversations are managed locally\n    throw new Error('Conversation not found - using local storage');\n  }\n  async createConversation(userId, title) {\n    // For now, conversations are created locally in the hook\n    throw new Error('Conversations are managed locally');\n  }\n  async saveMessage(conversationId, message) {\n    // For now, messages are saved locally in the hook\n    // In future, this could integrate with Wexa's conversation storage\n    return;\n  }\n}\nexport const apiService = new ApiService();","map":{"version":3,"names":["WEXA_API_BASE_URL","process","env","REACT_APP_WEXA_API_BASE_URL","WEXA_API_KEY","REACT_APP_WEXA_API_KEY","WEXA_PROJECT_ID","REACT_APP_WEXA_PROJECT_ID","WEXA_PROCESS_FLOW_ID","REACT_APP_WEXA_PROCESS_FLOW_ID","ApiService","wexaRequest","endpoint","options","url","config","headers","response","fetch","ok","Error","status","json","error","console","sendQuery","queryRequest","agentflow_id","executed_by","user_id","goal","input_variables","user_query","query","session_id","projectID","wexaResponse","method","body","JSON","stringify","executionResult","pollExecutionResult","execution_id","transformWexaResponse","answer","sources","executionId","maxAttempts","attempt","result","log","Promise","resolve","setTimeout","getExecutionDetails","originalQuery","conclusion","agents_output","length","lastOutput","output","content","filter","documents","flatMap","map","source","index","document_id","id","relevance_score","score","text","summary","metadata","type","getConversations","userId","getConversation","conversationId","createConversation","title","saveMessage","message","apiService"],"sources":["C:/Users/ashwi/OneDrive/Desktop/LightRiver UI/src/services/api.ts"],"sourcesContent":["import { QueryRequest, QueryResponse, Conversation, Message, WexaExecuteFlowRequest, WexaExecuteFlowResponse } from '../types';\n\nconst WEXA_API_BASE_URL = process.env.REACT_APP_WEXA_API_BASE_URL || 'https://api.wexa.ai';\nconst WEXA_API_KEY = process.env.REACT_APP_WEXA_API_KEY || 'ddee0dbb-08d1-48de-898b-67f77df8f773';\nconst WEXA_PROJECT_ID = process.env.REACT_APP_WEXA_PROJECT_ID || '68b6dc5d139ecd7045afa6b6';\nconst WEXA_PROCESS_FLOW_ID = process.env.REACT_APP_WEXA_PROCESS_FLOW_ID || '68b6dc89625644b8e9361e55';\n\nclass ApiService {\n  private async wexaRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const url = `${WEXA_API_BASE_URL}${endpoint}`;\n    const config: RequestInit = {\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': WEXA_API_KEY,\n        ...options.headers,\n      },\n      ...options,\n    };\n\n    try {\n      const response = await fetch(url, config);\n      \n      if (!response.ok) {\n        throw new Error(`Wexa API error! status: ${response.status}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      console.error('Wexa API request failed:', error);\n      throw error;\n    }\n  }\n\n  async sendQuery(queryRequest: QueryRequest): Promise<QueryResponse> {\n    try {\n      // Execute the Wexa co-worker process flow\n      const wexaRequest: WexaExecuteFlowRequest = {\n        agentflow_id: WEXA_PROCESS_FLOW_ID,\n        executed_by: queryRequest.user_id,\n        goal: \"process_user_query\",\n        input_variables: {\n          user_query: queryRequest.query,\n          session_id: queryRequest.session_id,\n        },\n        projectID: WEXA_PROJECT_ID,\n      };\n\n      const wexaResponse = await this.wexaRequest<WexaExecuteFlowResponse>(\n        `/execute_flow?projectID=${WEXA_PROJECT_ID}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(wexaRequest),\n        }\n      );\n\n      // Poll for execution completion and get results\n      const executionResult = await this.pollExecutionResult(wexaResponse.execution_id);\n\n      // Transform Wexa response to our expected format\n      return this.transformWexaResponse(executionResult, queryRequest.query);\n    } catch (error) {\n      console.error('Error executing Wexa co-worker:', error);\n      \n      // Fallback response for demo/testing\n      return {\n        answer: `I apologize, but I encountered an issue while processing your query: \"${queryRequest.query}\". Please ensure the Wexa co-worker is properly configured and try again.`,\n        sources: [],\n      };\n    }\n  }\n\n  private async pollExecutionResult(executionId: string, maxAttempts: number = 30): Promise<any> {\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        const result = await this.wexaRequest<any>(\n          `/execute_flow/execution/${executionId}?projectID=${WEXA_PROJECT_ID}`\n        );\n\n        console.log(`Polling attempt ${attempt + 1}: Status = ${result.status}`);\n\n        if (result.status === 'completed' || result.status === 'finished') {\n          return result;\n        }\n\n        if (result.status === 'failed' || result.status === 'error') {\n          throw new Error(`Execution failed: ${result.error || 'Unknown error'}`);\n        }\n\n        // Wait 2 seconds before next poll\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      } catch (error) {\n        console.error(`Polling attempt ${attempt + 1} failed:`, error);\n        if (attempt === maxAttempts - 1) {\n          throw error;\n        }\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n    }\n    \n    throw new Error('Execution timeout - process took too long to complete');\n  }\n\n  async getExecutionDetails(executionId: string): Promise<any> {\n    return this.wexaRequest<any>(\n      `/execute_flow/execution/${executionId}?projectID=${WEXA_PROJECT_ID}`\n    );\n  }\n\n  private transformWexaResponse(executionResult: any, originalQuery: string): QueryResponse {\n    let answer = 'I processed your query but did not receive a clear response.';\n    let sources: any[] = [];\n\n    // Extract answer from agents_output or conclusion\n    if (executionResult.conclusion) {\n      answer = executionResult.conclusion;\n    } else if (executionResult.agents_output && executionResult.agents_output.length > 0) {\n      const lastOutput = executionResult.agents_output[executionResult.agents_output.length - 1];\n      answer = lastOutput.output || lastOutput.response || lastOutput.content || answer;\n    }\n\n    // Extract sources if available in the execution result\n    if (executionResult.sources) {\n      sources = executionResult.sources;\n    } else if (executionResult.agents_output) {\n      // Try to extract sources from agent outputs\n      sources = executionResult.agents_output\n        .filter((output: any) => output.sources || output.documents)\n        .flatMap((output: any) => output.sources || output.documents || []);\n    }\n\n    return {\n      answer,\n      sources: sources.map((source: any, index: number) => ({\n        document_id: source.document_id || source.id || `doc_${index}`,\n        relevance_score: source.relevance_score || source.score || 0.8,\n        content: source.content || source.text || source.summary || '',\n        metadata: source.metadata || { type: 'knowledge_base' },\n      })),\n    };\n  }\n\n  async getConversations(userId: string): Promise<Conversation[]> {\n    // For now, return empty array as conversations are managed locally\n    // In future, this could integrate with Wexa's conversation storage\n    return [];\n  }\n\n  async getConversation(conversationId: string): Promise<Conversation> {\n    // For now, throw error as conversations are managed locally\n    throw new Error('Conversation not found - using local storage');\n  }\n\n  async createConversation(userId: string, title: string): Promise<Conversation> {\n    // For now, conversations are created locally in the hook\n    throw new Error('Conversations are managed locally');\n  }\n\n  async saveMessage(conversationId: string, message: Message): Promise<void> {\n    // For now, messages are saved locally in the hook\n    // In future, this could integrate with Wexa's conversation storage\n    return;\n  }\n}\n\nexport const apiService = new ApiService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
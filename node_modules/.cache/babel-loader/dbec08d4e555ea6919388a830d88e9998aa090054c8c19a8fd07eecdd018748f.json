{"ast":null,"code":"const WEXA_API_BASE_URL = process.env.REACT_APP_WEXA_API_BASE_URL || 'https://api.wexa.ai';\nconst WEXA_API_KEY = process.env.REACT_APP_WEXA_API_KEY || '94153bc4-224f-49a6-9af7-2d5394059cca';\nconst WEXA_PROJECT_ID = process.env.REACT_APP_WEXA_PROJECT_ID || '68b6dc5d139ecd7045afa6b6';\nconst WEXA_PROCESS_FLOW_ID = process.env.REACT_APP_WEXA_PROCESS_FLOW_ID || '68b6dc89625644b8e9361e55';\nclass ApiService {\n  async wexaRequest(endpoint, options = {}) {\n    const url = `${WEXA_API_BASE_URL}${endpoint}`;\n    const config = {\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': WEXA_API_KEY,\n        ...options.headers\n      },\n      ...options\n    };\n    console.log('Making Wexa API request:', {\n      url,\n      method: config.method || 'GET',\n      headers: config.headers,\n      apiKey: WEXA_API_KEY ? `${WEXA_API_KEY.substring(0, 8)}...` : 'NOT_SET'\n    });\n    try {\n      const response = await fetch(url, config);\n      console.log('Wexa API response status:', response.status, response.statusText);\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('Wexa API error response:', errorText);\n        throw new Error(`Wexa API error! status: ${response.status} - ${response.statusText}. Response: ${errorText}`);\n      }\n      const responseData = await response.json();\n      console.log('Wexa API response data:', responseData);\n      return responseData;\n    } catch (error) {\n      console.error('Wexa API request failed:', error);\n      throw error;\n    }\n  }\n  async sendQuery(queryRequest) {\n    try {\n      console.log('Starting Wexa API request with credentials:', {\n        projectID: WEXA_PROJECT_ID,\n        processFlowID: WEXA_PROCESS_FLOW_ID,\n        apiBaseUrl: WEXA_API_BASE_URL,\n        apiKeyFromEnv: process.env.REACT_APP_WEXA_API_KEY,\n        apiKeyUsed: WEXA_API_KEY\n      });\n\n      // Execute the Wexa co-worker process flow\n      const wexaRequest = {\n        agentflow_id: WEXA_PROCESS_FLOW_ID,\n        executed_by: '670cbc86906f68d0ec2970a9',\n        goal: \"run\",\n        input_variables: {},\n        projectID: WEXA_PROJECT_ID,\n        query: queryRequest.query\n      };\n      console.log('Sending Wexa request:', wexaRequest);\n      console.log('Request JSON:', JSON.stringify(wexaRequest, null, 2));\n      const wexaResponse = await this.wexaRequest(`/execute_flow`, {\n        method: 'POST',\n        body: JSON.stringify(wexaRequest)\n      });\n      console.log('Received Wexa response:', wexaResponse);\n\n      // Poll for execution completion and get results\n      const executionResult = await this.pollExecutionResult(wexaResponse.execution_id);\n\n      // Transform Wexa response to our expected format\n      return this.transformWexaResponse(executionResult, queryRequest.query);\n    } catch (error) {\n      console.error('Error executing Wexa co-worker:', error);\n\n      // More detailed error message\n      let errorMessage = `I encountered an issue while processing your query: \"${queryRequest.query}\".`;\n      if (error instanceof Error) {\n        if (error.message.includes('404')) {\n          errorMessage += ' The API endpoint was not found. Please check the process flow ID.';\n        } else if (error.message.includes('401') || error.message.includes('403')) {\n          errorMessage += ' Authentication failed. Please check the API key.';\n        } else if (error.message.includes('timeout')) {\n          errorMessage += ' The request timed out. The co-worker may be taking longer than expected.';\n        } else {\n          errorMessage += ` Error: ${error.message}`;\n        }\n      }\n      return {\n        answer: errorMessage,\n        sources: []\n      };\n    }\n  }\n  async pollExecutionResult(executionId, maxAttempts = 30) {\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        // Use the correct Wexa API endpoint for getting execution details\n        const result = await this.wexaRequest(`/execute_flow/${executionId}/execute?projectID=${WEXA_PROJECT_ID}`);\n        console.log(`Polling attempt ${attempt + 1}: Status = ${result.status}`, result);\n        if (result.status === 'completed' || result.status === 'finished') {\n          return result;\n        }\n        if (result.status === 'failed' || result.status === 'error') {\n          throw new Error(`Execution failed: ${result.error || 'Unknown error'}`);\n        }\n\n        // Wait 2 seconds before next poll\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      } catch (error) {\n        console.error(`Polling attempt ${attempt + 1} failed:`, error);\n        if (attempt === maxAttempts - 1) {\n          throw error;\n        }\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n    }\n    throw new Error('Execution timeout - process took too long to complete');\n  }\n  async getExecutionDetails(executionId) {\n    return this.wexaRequest(`/execute_flow/execution/${executionId}?projectID=${WEXA_PROJECT_ID}`);\n  }\n  transformWexaResponse(executionResult, originalQuery) {\n    let answer = 'I processed your query but did not receive a clear response.';\n    let sources = [];\n\n    // Extract answer from agents_output or conclusion\n    if (executionResult.conclusion) {\n      answer = executionResult.conclusion;\n    } else if (executionResult.agents_output && executionResult.agents_output.length > 0) {\n      const lastOutput = executionResult.agents_output[executionResult.agents_output.length - 1];\n      answer = lastOutput.output || lastOutput.response || lastOutput.content || answer;\n    }\n\n    // Extract sources if available in the execution result\n    if (executionResult.sources) {\n      sources = executionResult.sources;\n    } else if (executionResult.agents_output) {\n      // Try to extract sources from agent outputs\n      sources = executionResult.agents_output.filter(output => output.sources || output.documents).flatMap(output => output.sources || output.documents || []);\n    }\n    return {\n      answer,\n      sources: sources.map((source, index) => ({\n        document_id: source.document_id || source.id || `doc_${index}`,\n        relevance_score: source.relevance_score || source.score || 0.8,\n        content: source.content || source.text || source.summary || '',\n        metadata: source.metadata || {\n          type: 'knowledge_base'\n        }\n      }))\n    };\n  }\n  async getConversations(userId) {\n    // For now, return empty array as conversations are managed locally\n    // In future, this could integrate with Wexa's conversation storage\n    return [];\n  }\n  async getConversation(conversationId) {\n    // For now, throw error as conversations are managed locally\n    throw new Error('Conversation not found - using local storage');\n  }\n  async createConversation(userId, title) {\n    // For now, conversations are created locally in the hook\n    throw new Error('Conversations are managed locally');\n  }\n  async saveMessage(conversationId, message) {\n    // For now, messages are saved locally in the hook\n    // In future, this could integrate with Wexa's conversation storage\n    return;\n  }\n}\nexport const apiService = new ApiService();","map":{"version":3,"names":["WEXA_API_BASE_URL","process","env","REACT_APP_WEXA_API_BASE_URL","WEXA_API_KEY","REACT_APP_WEXA_API_KEY","WEXA_PROJECT_ID","REACT_APP_WEXA_PROJECT_ID","WEXA_PROCESS_FLOW_ID","REACT_APP_WEXA_PROCESS_FLOW_ID","ApiService","wexaRequest","endpoint","options","url","config","headers","console","log","method","apiKey","substring","response","fetch","status","statusText","ok","errorText","text","error","Error","responseData","json","sendQuery","queryRequest","projectID","processFlowID","apiBaseUrl","apiKeyFromEnv","apiKeyUsed","agentflow_id","executed_by","goal","input_variables","query","JSON","stringify","wexaResponse","body","executionResult","pollExecutionResult","execution_id","transformWexaResponse","errorMessage","message","includes","answer","sources","executionId","maxAttempts","attempt","result","Promise","resolve","setTimeout","getExecutionDetails","originalQuery","conclusion","agents_output","length","lastOutput","output","content","filter","documents","flatMap","map","source","index","document_id","id","relevance_score","score","summary","metadata","type","getConversations","userId","getConversation","conversationId","createConversation","title","saveMessage","apiService"],"sources":["C:/Users/ashwi/OneDrive/Desktop/LightRiver UI/src/services/api.ts"],"sourcesContent":["import { QueryRequest, QueryResponse, Conversation, Message, WexaExecuteFlowRequest, WexaExecuteFlowResponse } from '../types';\n\nconst WEXA_API_BASE_URL = process.env.REACT_APP_WEXA_API_BASE_URL || 'https://api.wexa.ai';\nconst WEXA_API_KEY = process.env.REACT_APP_WEXA_API_KEY || '94153bc4-224f-49a6-9af7-2d5394059cca';\nconst WEXA_PROJECT_ID = process.env.REACT_APP_WEXA_PROJECT_ID || '68b6dc5d139ecd7045afa6b6';\nconst WEXA_PROCESS_FLOW_ID = process.env.REACT_APP_WEXA_PROCESS_FLOW_ID || '68b6dc89625644b8e9361e55';\n\nclass ApiService {\n  private async wexaRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const url = `${WEXA_API_BASE_URL}${endpoint}`;\n    const config: RequestInit = {\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': WEXA_API_KEY,\n        ...options.headers,\n      },\n      ...options,\n    };\n\n    console.log('Making Wexa API request:', { \n      url, \n      method: config.method || 'GET',\n      headers: config.headers,\n      apiKey: WEXA_API_KEY ? `${WEXA_API_KEY.substring(0, 8)}...` : 'NOT_SET'\n    });\n\n    try {\n      const response = await fetch(url, config);\n      \n      console.log('Wexa API response status:', response.status, response.statusText);\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('Wexa API error response:', errorText);\n        throw new Error(`Wexa API error! status: ${response.status} - ${response.statusText}. Response: ${errorText}`);\n      }\n      \n      const responseData = await response.json();\n      console.log('Wexa API response data:', responseData);\n      return responseData;\n    } catch (error) {\n      console.error('Wexa API request failed:', error);\n      throw error;\n    }\n  }\n\n  async sendQuery(queryRequest: QueryRequest): Promise<QueryResponse> {\n    try {\n      console.log('Starting Wexa API request with credentials:', {\n        projectID: WEXA_PROJECT_ID,\n        processFlowID: WEXA_PROCESS_FLOW_ID,\n        apiBaseUrl: WEXA_API_BASE_URL,\n        apiKeyFromEnv: process.env.REACT_APP_WEXA_API_KEY,\n        apiKeyUsed: WEXA_API_KEY\n      });\n\n      // Execute the Wexa co-worker process flow\n      const wexaRequest: WexaExecuteFlowRequest = {\n        agentflow_id: WEXA_PROCESS_FLOW_ID,\n        executed_by: '670cbc86906f68d0ec2970a9',\n        goal: \"run\",\n        input_variables: {},\n        projectID: WEXA_PROJECT_ID,\n        query: queryRequest.query\n      };\n\n      console.log('Sending Wexa request:', wexaRequest);\n      console.log('Request JSON:', JSON.stringify(wexaRequest, null, 2));\n\n      const wexaResponse = await this.wexaRequest<WexaExecuteFlowResponse>(\n        `/execute_flow`,\n        {\n          method: 'POST',\n          body: JSON.stringify(wexaRequest),\n        }\n      );\n\n      console.log('Received Wexa response:', wexaResponse);\n\n      // Poll for execution completion and get results\n      const executionResult = await this.pollExecutionResult(wexaResponse.execution_id);\n\n      // Transform Wexa response to our expected format\n      return this.transformWexaResponse(executionResult, queryRequest.query);\n    } catch (error) {\n      console.error('Error executing Wexa co-worker:', error);\n      \n      // More detailed error message\n      let errorMessage = `I encountered an issue while processing your query: \"${queryRequest.query}\".`;\n      \n      if (error instanceof Error) {\n        if (error.message.includes('404')) {\n          errorMessage += ' The API endpoint was not found. Please check the process flow ID.';\n        } else if (error.message.includes('401') || error.message.includes('403')) {\n          errorMessage += ' Authentication failed. Please check the API key.';\n        } else if (error.message.includes('timeout')) {\n          errorMessage += ' The request timed out. The co-worker may be taking longer than expected.';\n        } else {\n          errorMessage += ` Error: ${error.message}`;\n        }\n      }\n      \n      return {\n        answer: errorMessage,\n        sources: [],\n      };\n    }\n  }\n\n  private async pollExecutionResult(executionId: string, maxAttempts: number = 30): Promise<any> {\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        // Use the correct Wexa API endpoint for getting execution details\n        const result = await this.wexaRequest<any>(\n          `/execute_flow/${executionId}/execute?projectID=${WEXA_PROJECT_ID}`\n        );\n\n        console.log(`Polling attempt ${attempt + 1}: Status = ${result.status}`, result);\n\n        if (result.status === 'completed' || result.status === 'finished') {\n          return result;\n        }\n\n        if (result.status === 'failed' || result.status === 'error') {\n          throw new Error(`Execution failed: ${result.error || 'Unknown error'}`);\n        }\n\n        // Wait 2 seconds before next poll\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      } catch (error) {\n        console.error(`Polling attempt ${attempt + 1} failed:`, error);\n        \n        if (attempt === maxAttempts - 1) {\n          throw error;\n        }\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n    }\n    \n    throw new Error('Execution timeout - process took too long to complete');\n  }\n\n  async getExecutionDetails(executionId: string): Promise<any> {\n    return this.wexaRequest<any>(\n      `/execute_flow/execution/${executionId}?projectID=${WEXA_PROJECT_ID}`\n    );\n  }\n\n  private transformWexaResponse(executionResult: any, originalQuery: string): QueryResponse {\n    let answer = 'I processed your query but did not receive a clear response.';\n    let sources: any[] = [];\n\n    // Extract answer from agents_output or conclusion\n    if (executionResult.conclusion) {\n      answer = executionResult.conclusion;\n    } else if (executionResult.agents_output && executionResult.agents_output.length > 0) {\n      const lastOutput = executionResult.agents_output[executionResult.agents_output.length - 1];\n      answer = lastOutput.output || lastOutput.response || lastOutput.content || answer;\n    }\n\n    // Extract sources if available in the execution result\n    if (executionResult.sources) {\n      sources = executionResult.sources;\n    } else if (executionResult.agents_output) {\n      // Try to extract sources from agent outputs\n      sources = executionResult.agents_output\n        .filter((output: any) => output.sources || output.documents)\n        .flatMap((output: any) => output.sources || output.documents || []);\n    }\n\n    return {\n      answer,\n      sources: sources.map((source: any, index: number) => ({\n        document_id: source.document_id || source.id || `doc_${index}`,\n        relevance_score: source.relevance_score || source.score || 0.8,\n        content: source.content || source.text || source.summary || '',\n        metadata: source.metadata || { type: 'knowledge_base' },\n      })),\n    };\n  }\n\n  async getConversations(userId: string): Promise<Conversation[]> {\n    // For now, return empty array as conversations are managed locally\n    // In future, this could integrate with Wexa's conversation storage\n    return [];\n  }\n\n  async getConversation(conversationId: string): Promise<Conversation> {\n    // For now, throw error as conversations are managed locally\n    throw new Error('Conversation not found - using local storage');\n  }\n\n  async createConversation(userId: string, title: string): Promise<Conversation> {\n    // For now, conversations are created locally in the hook\n    throw new Error('Conversations are managed locally');\n  }\n\n  async saveMessage(conversationId: string, message: Message): Promise<void> {\n    // For now, messages are saved locally in the hook\n    // In future, this could integrate with Wexa's conversation storage\n    return;\n  }\n}\n\nexport const apiService = new ApiService();\n"],"mappings":"AAEA,MAAMA,iBAAiB,GAAGC,OAAO,CAACC,GAAG,CAACC,2BAA2B,IAAI,qBAAqB;AAC1F,MAAMC,YAAY,GAAGH,OAAO,CAACC,GAAG,CAACG,sBAAsB,IAAI,sCAAsC;AACjG,MAAMC,eAAe,GAAGL,OAAO,CAACC,GAAG,CAACK,yBAAyB,IAAI,0BAA0B;AAC3F,MAAMC,oBAAoB,GAAGP,OAAO,CAACC,GAAG,CAACO,8BAA8B,IAAI,0BAA0B;AAErG,MAAMC,UAAU,CAAC;EACf,MAAcC,WAAWA,CAAIC,QAAgB,EAAEC,OAAoB,GAAG,CAAC,CAAC,EAAc;IACpF,MAAMC,GAAG,GAAG,GAAGd,iBAAiB,GAAGY,QAAQ,EAAE;IAC7C,MAAMG,MAAmB,GAAG;MAC1BC,OAAO,EAAE;QACP,cAAc,EAAE,kBAAkB;QAClC,WAAW,EAAEZ,YAAY;QACzB,GAAGS,OAAO,CAACG;MACb,CAAC;MACD,GAAGH;IACL,CAAC;IAEDI,OAAO,CAACC,GAAG,CAAC,0BAA0B,EAAE;MACtCJ,GAAG;MACHK,MAAM,EAAEJ,MAAM,CAACI,MAAM,IAAI,KAAK;MAC9BH,OAAO,EAAED,MAAM,CAACC,OAAO;MACvBI,MAAM,EAAEhB,YAAY,GAAG,GAAGA,YAAY,CAACiB,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG;IAChE,CAAC,CAAC;IAEF,IAAI;MACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACT,GAAG,EAAEC,MAAM,CAAC;MAEzCE,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEI,QAAQ,CAACE,MAAM,EAAEF,QAAQ,CAACG,UAAU,CAAC;MAE9E,IAAI,CAACH,QAAQ,CAACI,EAAE,EAAE;QAChB,MAAMC,SAAS,GAAG,MAAML,QAAQ,CAACM,IAAI,CAAC,CAAC;QACvCX,OAAO,CAACY,KAAK,CAAC,0BAA0B,EAAEF,SAAS,CAAC;QACpD,MAAM,IAAIG,KAAK,CAAC,2BAA2BR,QAAQ,CAACE,MAAM,MAAMF,QAAQ,CAACG,UAAU,eAAeE,SAAS,EAAE,CAAC;MAChH;MAEA,MAAMI,YAAY,GAAG,MAAMT,QAAQ,CAACU,IAAI,CAAC,CAAC;MAC1Cf,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEa,YAAY,CAAC;MACpD,OAAOA,YAAY;IACrB,CAAC,CAAC,OAAOF,KAAK,EAAE;MACdZ,OAAO,CAACY,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD,MAAMA,KAAK;IACb;EACF;EAEA,MAAMI,SAASA,CAACC,YAA0B,EAA0B;IAClE,IAAI;MACFjB,OAAO,CAACC,GAAG,CAAC,6CAA6C,EAAE;QACzDiB,SAAS,EAAE7B,eAAe;QAC1B8B,aAAa,EAAE5B,oBAAoB;QACnC6B,UAAU,EAAErC,iBAAiB;QAC7BsC,aAAa,EAAErC,OAAO,CAACC,GAAG,CAACG,sBAAsB;QACjDkC,UAAU,EAAEnC;MACd,CAAC,CAAC;;MAEF;MACA,MAAMO,WAAmC,GAAG;QAC1C6B,YAAY,EAAEhC,oBAAoB;QAClCiC,WAAW,EAAE,0BAA0B;QACvCC,IAAI,EAAE,KAAK;QACXC,eAAe,EAAE,CAAC,CAAC;QACnBR,SAAS,EAAE7B,eAAe;QAC1BsC,KAAK,EAAEV,YAAY,CAACU;MACtB,CAAC;MAED3B,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEP,WAAW,CAAC;MACjDM,OAAO,CAACC,GAAG,CAAC,eAAe,EAAE2B,IAAI,CAACC,SAAS,CAACnC,WAAW,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;MAElE,MAAMoC,YAAY,GAAG,MAAM,IAAI,CAACpC,WAAW,CACzC,eAAe,EACf;QACEQ,MAAM,EAAE,MAAM;QACd6B,IAAI,EAAEH,IAAI,CAACC,SAAS,CAACnC,WAAW;MAClC,CACF,CAAC;MAEDM,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAE6B,YAAY,CAAC;;MAEpD;MACA,MAAME,eAAe,GAAG,MAAM,IAAI,CAACC,mBAAmB,CAACH,YAAY,CAACI,YAAY,CAAC;;MAEjF;MACA,OAAO,IAAI,CAACC,qBAAqB,CAACH,eAAe,EAAEf,YAAY,CAACU,KAAK,CAAC;IACxE,CAAC,CAAC,OAAOf,KAAK,EAAE;MACdZ,OAAO,CAACY,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;;MAEvD;MACA,IAAIwB,YAAY,GAAG,wDAAwDnB,YAAY,CAACU,KAAK,IAAI;MAEjG,IAAIf,KAAK,YAAYC,KAAK,EAAE;QAC1B,IAAID,KAAK,CAACyB,OAAO,CAACC,QAAQ,CAAC,KAAK,CAAC,EAAE;UACjCF,YAAY,IAAI,oEAAoE;QACtF,CAAC,MAAM,IAAIxB,KAAK,CAACyB,OAAO,CAACC,QAAQ,CAAC,KAAK,CAAC,IAAI1B,KAAK,CAACyB,OAAO,CAACC,QAAQ,CAAC,KAAK,CAAC,EAAE;UACzEF,YAAY,IAAI,mDAAmD;QACrE,CAAC,MAAM,IAAIxB,KAAK,CAACyB,OAAO,CAACC,QAAQ,CAAC,SAAS,CAAC,EAAE;UAC5CF,YAAY,IAAI,2EAA2E;QAC7F,CAAC,MAAM;UACLA,YAAY,IAAI,WAAWxB,KAAK,CAACyB,OAAO,EAAE;QAC5C;MACF;MAEA,OAAO;QACLE,MAAM,EAAEH,YAAY;QACpBI,OAAO,EAAE;MACX,CAAC;IACH;EACF;EAEA,MAAcP,mBAAmBA,CAACQ,WAAmB,EAAEC,WAAmB,GAAG,EAAE,EAAgB;IAC7F,KAAK,IAAIC,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAGD,WAAW,EAAEC,OAAO,EAAE,EAAE;MACtD,IAAI;QACF;QACA,MAAMC,MAAM,GAAG,MAAM,IAAI,CAAClD,WAAW,CACnC,iBAAiB+C,WAAW,sBAAsBpD,eAAe,EACnE,CAAC;QAEDW,OAAO,CAACC,GAAG,CAAC,mBAAmB0C,OAAO,GAAG,CAAC,cAAcC,MAAM,CAACrC,MAAM,EAAE,EAAEqC,MAAM,CAAC;QAEhF,IAAIA,MAAM,CAACrC,MAAM,KAAK,WAAW,IAAIqC,MAAM,CAACrC,MAAM,KAAK,UAAU,EAAE;UACjE,OAAOqC,MAAM;QACf;QAEA,IAAIA,MAAM,CAACrC,MAAM,KAAK,QAAQ,IAAIqC,MAAM,CAACrC,MAAM,KAAK,OAAO,EAAE;UAC3D,MAAM,IAAIM,KAAK,CAAC,qBAAqB+B,MAAM,CAAChC,KAAK,IAAI,eAAe,EAAE,CAAC;QACzE;;QAEA;QACA,MAAM,IAAIiC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;MACzD,CAAC,CAAC,OAAOlC,KAAK,EAAE;QACdZ,OAAO,CAACY,KAAK,CAAC,mBAAmB+B,OAAO,GAAG,CAAC,UAAU,EAAE/B,KAAK,CAAC;QAE9D,IAAI+B,OAAO,KAAKD,WAAW,GAAG,CAAC,EAAE;UAC/B,MAAM9B,KAAK;QACb;QACA,MAAM,IAAIiC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;MACzD;IACF;IAEA,MAAM,IAAIjC,KAAK,CAAC,uDAAuD,CAAC;EAC1E;EAEA,MAAMmC,mBAAmBA,CAACP,WAAmB,EAAgB;IAC3D,OAAO,IAAI,CAAC/C,WAAW,CACrB,2BAA2B+C,WAAW,cAAcpD,eAAe,EACrE,CAAC;EACH;EAEQ8C,qBAAqBA,CAACH,eAAoB,EAAEiB,aAAqB,EAAiB;IACxF,IAAIV,MAAM,GAAG,8DAA8D;IAC3E,IAAIC,OAAc,GAAG,EAAE;;IAEvB;IACA,IAAIR,eAAe,CAACkB,UAAU,EAAE;MAC9BX,MAAM,GAAGP,eAAe,CAACkB,UAAU;IACrC,CAAC,MAAM,IAAIlB,eAAe,CAACmB,aAAa,IAAInB,eAAe,CAACmB,aAAa,CAACC,MAAM,GAAG,CAAC,EAAE;MACpF,MAAMC,UAAU,GAAGrB,eAAe,CAACmB,aAAa,CAACnB,eAAe,CAACmB,aAAa,CAACC,MAAM,GAAG,CAAC,CAAC;MAC1Fb,MAAM,GAAGc,UAAU,CAACC,MAAM,IAAID,UAAU,CAAChD,QAAQ,IAAIgD,UAAU,CAACE,OAAO,IAAIhB,MAAM;IACnF;;IAEA;IACA,IAAIP,eAAe,CAACQ,OAAO,EAAE;MAC3BA,OAAO,GAAGR,eAAe,CAACQ,OAAO;IACnC,CAAC,MAAM,IAAIR,eAAe,CAACmB,aAAa,EAAE;MACxC;MACAX,OAAO,GAAGR,eAAe,CAACmB,aAAa,CACpCK,MAAM,CAAEF,MAAW,IAAKA,MAAM,CAACd,OAAO,IAAIc,MAAM,CAACG,SAAS,CAAC,CAC3DC,OAAO,CAAEJ,MAAW,IAAKA,MAAM,CAACd,OAAO,IAAIc,MAAM,CAACG,SAAS,IAAI,EAAE,CAAC;IACvE;IAEA,OAAO;MACLlB,MAAM;MACNC,OAAO,EAAEA,OAAO,CAACmB,GAAG,CAAC,CAACC,MAAW,EAAEC,KAAa,MAAM;QACpDC,WAAW,EAAEF,MAAM,CAACE,WAAW,IAAIF,MAAM,CAACG,EAAE,IAAI,OAAOF,KAAK,EAAE;QAC9DG,eAAe,EAAEJ,MAAM,CAACI,eAAe,IAAIJ,MAAM,CAACK,KAAK,IAAI,GAAG;QAC9DV,OAAO,EAAEK,MAAM,CAACL,OAAO,IAAIK,MAAM,CAACjD,IAAI,IAAIiD,MAAM,CAACM,OAAO,IAAI,EAAE;QAC9DC,QAAQ,EAAEP,MAAM,CAACO,QAAQ,IAAI;UAAEC,IAAI,EAAE;QAAiB;MACxD,CAAC,CAAC;IACJ,CAAC;EACH;EAEA,MAAMC,gBAAgBA,CAACC,MAAc,EAA2B;IAC9D;IACA;IACA,OAAO,EAAE;EACX;EAEA,MAAMC,eAAeA,CAACC,cAAsB,EAAyB;IACnE;IACA,MAAM,IAAI3D,KAAK,CAAC,8CAA8C,CAAC;EACjE;EAEA,MAAM4D,kBAAkBA,CAACH,MAAc,EAAEI,KAAa,EAAyB;IAC7E;IACA,MAAM,IAAI7D,KAAK,CAAC,mCAAmC,CAAC;EACtD;EAEA,MAAM8D,WAAWA,CAACH,cAAsB,EAAEnC,OAAgB,EAAiB;IACzE;IACA;IACA;EACF;AACF;AAEA,OAAO,MAAMuC,UAAU,GAAG,IAAInF,UAAU,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
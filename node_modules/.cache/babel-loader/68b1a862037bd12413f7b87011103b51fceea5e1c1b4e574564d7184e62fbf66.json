{"ast":null,"code":"import _objectSpread from\"C:/Users/ashwi/OneDrive/Desktop/LightRiver UI/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";const WEXA_API_BASE_URL=process.env.REACT_APP_WEXA_API_BASE_URL||'https://api.wexa.ai';const WEXA_API_KEY=process.env.REACT_APP_WEXA_API_KEY||'ddee0dbb-08d1-48de-898b-67f77df8f773';const WEXA_PROJECT_ID=process.env.REACT_APP_WEXA_PROJECT_ID||'68b6dc5d139ecd7045afa6b6';const WEXA_PROCESS_FLOW_ID=process.env.REACT_APP_WEXA_PROCESS_FLOW_ID||'68b6dc89625644b8e9361e55';class ApiService{async wexaRequest(endpoint){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const url=\"\".concat(WEXA_API_BASE_URL).concat(endpoint);const config=_objectSpread({headers:_objectSpread({'Content-Type':'application/json','x-api-key':WEXA_API_KEY},options.headers)},options);console.log('Making Wexa API request:',{url,method:config.method||'GET'});try{const response=await fetch(url,config);console.log('Wexa API response status:',response.status,response.statusText);if(!response.ok){const errorText=await response.text();console.error('Wexa API error response:',errorText);throw new Error(\"Wexa API error! status: \".concat(response.status,\" - \").concat(response.statusText,\". Response: \").concat(errorText));}const responseData=await response.json();console.log('Wexa API response data:',responseData);return responseData;}catch(error){console.error('Wexa API request failed:',error);throw error;}}async sendQuery(queryRequest){try{console.log('Starting Wexa API request with credentials:',{projectID:WEXA_PROJECT_ID,processFlowID:WEXA_PROCESS_FLOW_ID,apiBaseUrl:WEXA_API_BASE_URL});// Execute the Wexa co-worker process flow\nconst wexaRequest={agentflow_id:WEXA_PROCESS_FLOW_ID,executed_by:queryRequest.user_id,goal:\"run\",input_variables:{user_query:queryRequest.query,session_id:queryRequest.session_id},projectID:WEXA_PROJECT_ID};console.log('Sending Wexa request:',wexaRequest);const wexaResponse=await this.wexaRequest(\"/execute_flow?projectID=\".concat(WEXA_PROJECT_ID),{method:'POST',body:JSON.stringify(wexaRequest)});console.log('Received Wexa response:',wexaResponse);// Poll for execution completion and get results\nconst executionResult=await this.pollExecutionResult(wexaResponse.execution_id);// Transform Wexa response to our expected format\nreturn this.transformWexaResponse(executionResult,queryRequest.query);}catch(error){console.error('Error executing Wexa co-worker:',error);// More detailed error message\nlet errorMessage=\"I encountered an issue while processing your query: \\\"\".concat(queryRequest.query,\"\\\".\");if(error instanceof Error){if(error.message.includes('404')){errorMessage+=' The API endpoint was not found. Please check the process flow ID.';}else if(error.message.includes('401')||error.message.includes('403')){errorMessage+=' Authentication failed. Please check the API key.';}else if(error.message.includes('timeout')){errorMessage+=' The request timed out. The co-worker may be taking longer than expected.';}else{errorMessage+=\" Error: \".concat(error.message);}}return{answer:errorMessage,sources:[]};}}async pollExecutionResult(executionId){let maxAttempts=arguments.length>1&&arguments[1]!==undefined?arguments[1]:30;for(let attempt=0;attempt<maxAttempts;attempt++){try{// Try different endpoint patterns based on Wexa documentation\nconst result=await this.wexaRequest(\"/execute_flow/\".concat(executionId,\"/execute?projectID=\").concat(WEXA_PROJECT_ID));console.log(\"Polling attempt \".concat(attempt+1,\": Status = \").concat(result.status),result);if(result.status==='completed'||result.status==='finished'){return result;}if(result.status==='failed'||result.status==='error'){throw new Error(\"Execution failed: \".concat(result.error||'Unknown error'));}// Wait 2 seconds before next poll\nawait new Promise(resolve=>setTimeout(resolve,2000));}catch(error){console.error(\"Polling attempt \".concat(attempt+1,\" failed:\"),error);// Try alternative endpoint for getting execution details\ntry{const altResult=await this.wexaRequest(\"/execute_flow/execution/\".concat(executionId,\"?projectID=\").concat(WEXA_PROJECT_ID));console.log(\"Alternative endpoint result:\",altResult);if(altResult.status==='completed'||altResult.status==='finished'){return altResult;}}catch(altError){console.error(\"Alternative endpoint also failed:\",altError);}if(attempt===maxAttempts-1){throw error;}await new Promise(resolve=>setTimeout(resolve,2000));}}throw new Error('Execution timeout - process took too long to complete');}async getExecutionDetails(executionId){return this.wexaRequest(\"/execute_flow/execution/\".concat(executionId,\"?projectID=\").concat(WEXA_PROJECT_ID));}transformWexaResponse(executionResult,originalQuery){let answer='I processed your query but did not receive a clear response.';let sources=[];// Extract answer from agents_output or conclusion\nif(executionResult.conclusion){answer=executionResult.conclusion;}else if(executionResult.agents_output&&executionResult.agents_output.length>0){const lastOutput=executionResult.agents_output[executionResult.agents_output.length-1];answer=lastOutput.output||lastOutput.response||lastOutput.content||answer;}// Extract sources if available in the execution result\nif(executionResult.sources){sources=executionResult.sources;}else if(executionResult.agents_output){// Try to extract sources from agent outputs\nsources=executionResult.agents_output.filter(output=>output.sources||output.documents).flatMap(output=>output.sources||output.documents||[]);}return{answer,sources:sources.map((source,index)=>({document_id:source.document_id||source.id||\"doc_\".concat(index),relevance_score:source.relevance_score||source.score||0.8,content:source.content||source.text||source.summary||'',metadata:source.metadata||{type:'knowledge_base'}}))};}async getConversations(userId){// For now, return empty array as conversations are managed locally\n// In future, this could integrate with Wexa's conversation storage\nreturn[];}async getConversation(conversationId){// For now, throw error as conversations are managed locally\nthrow new Error('Conversation not found - using local storage');}async createConversation(userId,title){// For now, conversations are created locally in the hook\nthrow new Error('Conversations are managed locally');}async saveMessage(conversationId,message){// For now, messages are saved locally in the hook\n// In future, this could integrate with Wexa's conversation storage\nreturn;}}export const apiService=new ApiService();","map":{"version":3,"names":["WEXA_API_BASE_URL","process","env","REACT_APP_WEXA_API_BASE_URL","WEXA_API_KEY","REACT_APP_WEXA_API_KEY","WEXA_PROJECT_ID","REACT_APP_WEXA_PROJECT_ID","WEXA_PROCESS_FLOW_ID","REACT_APP_WEXA_PROCESS_FLOW_ID","ApiService","wexaRequest","endpoint","options","arguments","length","undefined","url","concat","config","_objectSpread","headers","console","log","method","response","fetch","status","statusText","ok","errorText","text","error","Error","responseData","json","sendQuery","queryRequest","projectID","processFlowID","apiBaseUrl","agentflow_id","executed_by","user_id","goal","input_variables","user_query","query","session_id","wexaResponse","body","JSON","stringify","executionResult","pollExecutionResult","execution_id","transformWexaResponse","errorMessage","message","includes","answer","sources","executionId","maxAttempts","attempt","result","Promise","resolve","setTimeout","altResult","altError","getExecutionDetails","originalQuery","conclusion","agents_output","lastOutput","output","content","filter","documents","flatMap","map","source","index","document_id","id","relevance_score","score","summary","metadata","type","getConversations","userId","getConversation","conversationId","createConversation","title","saveMessage","apiService"],"sources":["C:/Users/ashwi/OneDrive/Desktop/LightRiver UI/src/services/api.ts"],"sourcesContent":["import { QueryRequest, QueryResponse, Conversation, Message, WexaExecuteFlowRequest, WexaExecuteFlowResponse } from '../types';\n\nconst WEXA_API_BASE_URL = process.env.REACT_APP_WEXA_API_BASE_URL || 'https://api.wexa.ai';\nconst WEXA_API_KEY = process.env.REACT_APP_WEXA_API_KEY || 'ddee0dbb-08d1-48de-898b-67f77df8f773';\nconst WEXA_PROJECT_ID = process.env.REACT_APP_WEXA_PROJECT_ID || '68b6dc5d139ecd7045afa6b6';\nconst WEXA_PROCESS_FLOW_ID = process.env.REACT_APP_WEXA_PROCESS_FLOW_ID || '68b6dc89625644b8e9361e55';\n\nclass ApiService {\n  private async wexaRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const url = `${WEXA_API_BASE_URL}${endpoint}`;\n    const config: RequestInit = {\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': WEXA_API_KEY,\n        ...options.headers,\n      },\n      ...options,\n    };\n\n    console.log('Making Wexa API request:', { url, method: config.method || 'GET' });\n\n    try {\n      const response = await fetch(url, config);\n      \n      console.log('Wexa API response status:', response.status, response.statusText);\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('Wexa API error response:', errorText);\n        throw new Error(`Wexa API error! status: ${response.status} - ${response.statusText}. Response: ${errorText}`);\n      }\n      \n      const responseData = await response.json();\n      console.log('Wexa API response data:', responseData);\n      return responseData;\n    } catch (error) {\n      console.error('Wexa API request failed:', error);\n      throw error;\n    }\n  }\n\n  async sendQuery(queryRequest: QueryRequest): Promise<QueryResponse> {\n    try {\n      console.log('Starting Wexa API request with credentials:', {\n        projectID: WEXA_PROJECT_ID,\n        processFlowID: WEXA_PROCESS_FLOW_ID,\n        apiBaseUrl: WEXA_API_BASE_URL\n      });\n\n      // Execute the Wexa co-worker process flow\n      const wexaRequest: WexaExecuteFlowRequest = {\n        agentflow_id: WEXA_PROCESS_FLOW_ID,\n        executed_by: queryRequest.user_id,\n        goal: \"run\",\n        input_variables: {\n          user_query: queryRequest.query,\n          session_id: queryRequest.session_id,\n        },\n        projectID: WEXA_PROJECT_ID,\n      };\n\n      console.log('Sending Wexa request:', wexaRequest);\n\n      const wexaResponse = await this.wexaRequest<WexaExecuteFlowResponse>(\n        `/execute_flow?projectID=${WEXA_PROJECT_ID}`,\n        {\n          method: 'POST',\n          body: JSON.stringify(wexaRequest),\n        }\n      );\n\n      console.log('Received Wexa response:', wexaResponse);\n\n      // Poll for execution completion and get results\n      const executionResult = await this.pollExecutionResult(wexaResponse.execution_id);\n\n      // Transform Wexa response to our expected format\n      return this.transformWexaResponse(executionResult, queryRequest.query);\n    } catch (error) {\n      console.error('Error executing Wexa co-worker:', error);\n      \n      // More detailed error message\n      let errorMessage = `I encountered an issue while processing your query: \"${queryRequest.query}\".`;\n      \n      if (error instanceof Error) {\n        if (error.message.includes('404')) {\n          errorMessage += ' The API endpoint was not found. Please check the process flow ID.';\n        } else if (error.message.includes('401') || error.message.includes('403')) {\n          errorMessage += ' Authentication failed. Please check the API key.';\n        } else if (error.message.includes('timeout')) {\n          errorMessage += ' The request timed out. The co-worker may be taking longer than expected.';\n        } else {\n          errorMessage += ` Error: ${error.message}`;\n        }\n      }\n      \n      return {\n        answer: errorMessage,\n        sources: [],\n      };\n    }\n  }\n\n  private async pollExecutionResult(executionId: string, maxAttempts: number = 30): Promise<any> {\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        // Try different endpoint patterns based on Wexa documentation\n        const result = await this.wexaRequest<any>(\n          `/execute_flow/${executionId}/execute?projectID=${WEXA_PROJECT_ID}`\n        );\n\n        console.log(`Polling attempt ${attempt + 1}: Status = ${result.status}`, result);\n\n        if (result.status === 'completed' || result.status === 'finished') {\n          return result;\n        }\n\n        if (result.status === 'failed' || result.status === 'error') {\n          throw new Error(`Execution failed: ${result.error || 'Unknown error'}`);\n        }\n\n        // Wait 2 seconds before next poll\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      } catch (error) {\n        console.error(`Polling attempt ${attempt + 1} failed:`, error);\n        \n        // Try alternative endpoint for getting execution details\n        try {\n          const altResult = await this.wexaRequest<any>(\n            `/execute_flow/execution/${executionId}?projectID=${WEXA_PROJECT_ID}`\n          );\n          console.log(`Alternative endpoint result:`, altResult);\n          \n          if (altResult.status === 'completed' || altResult.status === 'finished') {\n            return altResult;\n          }\n        } catch (altError) {\n          console.error(`Alternative endpoint also failed:`, altError);\n        }\n        \n        if (attempt === maxAttempts - 1) {\n          throw error;\n        }\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n    }\n    \n    throw new Error('Execution timeout - process took too long to complete');\n  }\n\n  async getExecutionDetails(executionId: string): Promise<any> {\n    return this.wexaRequest<any>(\n      `/execute_flow/execution/${executionId}?projectID=${WEXA_PROJECT_ID}`\n    );\n  }\n\n  private transformWexaResponse(executionResult: any, originalQuery: string): QueryResponse {\n    let answer = 'I processed your query but did not receive a clear response.';\n    let sources: any[] = [];\n\n    // Extract answer from agents_output or conclusion\n    if (executionResult.conclusion) {\n      answer = executionResult.conclusion;\n    } else if (executionResult.agents_output && executionResult.agents_output.length > 0) {\n      const lastOutput = executionResult.agents_output[executionResult.agents_output.length - 1];\n      answer = lastOutput.output || lastOutput.response || lastOutput.content || answer;\n    }\n\n    // Extract sources if available in the execution result\n    if (executionResult.sources) {\n      sources = executionResult.sources;\n    } else if (executionResult.agents_output) {\n      // Try to extract sources from agent outputs\n      sources = executionResult.agents_output\n        .filter((output: any) => output.sources || output.documents)\n        .flatMap((output: any) => output.sources || output.documents || []);\n    }\n\n    return {\n      answer,\n      sources: sources.map((source: any, index: number) => ({\n        document_id: source.document_id || source.id || `doc_${index}`,\n        relevance_score: source.relevance_score || source.score || 0.8,\n        content: source.content || source.text || source.summary || '',\n        metadata: source.metadata || { type: 'knowledge_base' },\n      })),\n    };\n  }\n\n  async getConversations(userId: string): Promise<Conversation[]> {\n    // For now, return empty array as conversations are managed locally\n    // In future, this could integrate with Wexa's conversation storage\n    return [];\n  }\n\n  async getConversation(conversationId: string): Promise<Conversation> {\n    // For now, throw error as conversations are managed locally\n    throw new Error('Conversation not found - using local storage');\n  }\n\n  async createConversation(userId: string, title: string): Promise<Conversation> {\n    // For now, conversations are created locally in the hook\n    throw new Error('Conversations are managed locally');\n  }\n\n  async saveMessage(conversationId: string, message: Message): Promise<void> {\n    // For now, messages are saved locally in the hook\n    // In future, this could integrate with Wexa's conversation storage\n    return;\n  }\n}\n\nexport const apiService = new ApiService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}